#include <iostream>

using namespace std;

// Функция вывода результата
bool result(const string& str, bool state)
{
    //    Как-то некрасиво выглядит. Слишком много дублирования кода, хотя логика простая. Исправить.
    // Исправил
    cout << str + (state ? " - правильная скобочная последовательность\n" : " - неправильная скобочная последовательность\n");

    //    Функция возвращает int, а не bool. Я понимаю, что так можно и будет каст к bool, но надо правильно
    // Исправил
    return true;
}

// Функция обработки строки
bool bracket_check(const string& str)
{
    bool state = true;      // Отображает правильно ли выражение
    int bracket_open = 0;   // Количество открытых скобок

    //    Есть структура данных - стэк. Слышал про такой? Переделывать не нужно, но имей ввиду, что через стэк эта задача решается проще.
    /*
          Изначально я хотел использовать стек, но подумал, что он утяжелит программу, поэтому решил обойтись без него.
          Сейчас я провел эксперимент, написал эту же функцию с использованием стека, из 10 запусков программы, на моем ПК имеем следующие результаты.
          При использовании стека,  максимальное время работы - 0.08с, минимальное - 0.03с, среднее - 0.04с, количество используемой памяти - 100б.
          Без использования стека,  максимальное время работы - 0.08с, минимальное - 0.03с, среднее - 0.04с, количество используемой памяти - 100б.
          Количество строк кода, в моем случаи, с использованием стека - 61, без использования стека - 74.
          Единственные отличия котрое я заметил, это то, что при использовании стека мне не понадобилось использовать дополнительную переменную,
          поэтому строк кода и получилось меньше, так же логика кода с использованием стека скорее всего понятнее, так как принцип работы стека известен всем программистам.

          Проведя эксперемент я убедился, что работа данной программы с использованием стека или без него сильно ничего не меняет,
          но небольшое преимущетсво это все же преимущество, поэтому использование стека было бы правильнее и проще.
    */
    for (int i = 0; i < str.size(); i++)
    {
        switch (str[i])
        {
        case '(':
            if (i != 0) // Если мы находимся в первом символе то пропускаем этот шаг
            {
                if (str[i - 1] == '(') // Если предыдущая скобка была открывающей, увеличиваем счетчик открытых скобок
                    bracket_open++;
                else if (str[i - 1] != '(' && str[i] == '(') // Иначе если предыдущая скобка НЕ была открывающей, а текущая является открывающей
                {
                    if (bracket_open < 0) // И если число закрывающих скобок меньше числа открывающих 
                        // То есть если последовательность заведомо неправильная, мы все равно идем до конца строки? Надо ли это?
                        // Не надо, исправил
                        state = false; // Получаем, что последовательность заведомо неправильная 
                    else
                        bracket_open++; // Иначе увеличиваем число открывающих скобок
                }
            }
            else
                bracket_open++; // И увеличиваем число открывающих скобок
            break;
        case ')':
            bracket_open--;
            break;
        default:
            break;
        }

        if (!state) // Если последовательнось заведомо неправильная, выходим из цикла 
            break;
    }

    // Проверяем соотвествуют ли полученные данные требуемым
    if (bracket_open != 0)
        state = false;

    return state;
}

int main()
{
    setlocale(LC_ALL, "Rus");

    // Тестовые комбинации
    string str = "((x * y) + (2 * (x + y))) * (y + 3)";
    result(str, bracket_check(str));
    str = "((((x * y) + (2 * (x - y)))";
    result(str, bracket_check(str));

    return 0;
}
